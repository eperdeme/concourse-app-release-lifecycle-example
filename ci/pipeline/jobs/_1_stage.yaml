jobs:
  #######################################################################
  ###################### app-code: artifact #############################
  #######################################################################
  - name: start-staging
    plan:
    - get: app-code-develop-repo
      trigger: true
    - get: staging-app-code-version
      params:
        pre: alpha
    # This no-op put or git push seems to be enough to always make sure that the latest repository is checked out
    # in concourse. Otherwise there is the problem that we use check_every: 5m on most resources to safe the waste
    # of resources.
    # Source:
    # In the post below, two repos are used, and the trigger is get and then pushed
    # to the same repo. This seems to ensure everything is on the most current state
    # https://github.com/concourse/concourse/issues/1719#issuecomment-336722092
    - put: app-code-develop-repo
      params:
        repository: app-code-develop-repo
    - put: staging-app-code-version
      params:
        file: staging-app-code-version/version

  - name: staging-build-app-artifact
    plan:
    - get: ci-repo
    - get: staging-app-code-version
      passed: [start-staging]
      trigger: true
    - get: app-code-develop-repo
      passed: [start-staging]
    - task: build-artificat
      file: ci-repo/ci/tasks/build-artifact.yaml
      input_mapping:
        app: app-code-develop-repo
        version: staging-app-code-version
      output_mapping:
        artifact: code-artifact
    # deploy / publish our artifact to our artifact storage
    - put: publish-staging-artificat
      resource: app-artifact
      params:
        # this is NOT regexp bu bashism wildcard!!
        file: code-artifact/myapp-*.tgz
    # be sure we save our bumped version
    - put: save-staging-version
      resource: staging-app-code-version
      params:
        file: staging-app-code-version/version

  #######################################################################
  ###################### app-code: Docker image #########################
  #######################################################################
  - name: staging-build-app-code-image
    plan:
    - get: app-artifact
      passed: [staging-build-app-artifact]
      trigger: true
    - get: staging-app-code-version
      passed: [staging-build-app-artifact]
    - get: ci-repo
    - get: app-code-develop-repo
    - task: staging-build-app-code-image
      file: ci-repo/ci/tasks/build-docker-context.yaml
      params:
        # the folder our Dockerfile and other docker context files are located in the input docker-repo
        DOCKER_PATH: './docker'
        # the filename of our app artifact in the app-artifact input
        APP_ARTIFACT_SOURCE_FILENAME: myapp-*.tgz
        # the expected filename of the app artifact in the Dockerfile of the app app-code image, see
        # https://github.com/kw-concourse-example/concourse-example-app/blob/master/docker/Dockerfile#L5
        APP_ARTIFACT_DEST_FILENAME: myapp.tgz
      input_mapping:
        # the input where are Dockerfile is located
        docker-repo: app-code-develop-repo
        # the input of our app artifact
        app-artificat: app-artifact
      output_mapping:
        # this will be a prepared docker-context, so the Dockerfile including all folders and the app artifact to build
        # using the docker-resource
        docker-build-context: build-context
    - put: app-code-docker-image
      get_params:
        skip_download : true
      params:
        build: build-context
        tag_as_latest: true
        # tag_file: staging-app-code-version/version

resources:
  - name: staging-app-code-version
    type: semver
    source:
      driver: git
      uri: ((app.git-repo))
      branch: version
      file: staging-version
      private_key: ((github-private-key))